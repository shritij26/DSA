# Dynamic Programming (DP)

> *â€œThose who forget the past are condemned to repeat it.â€*

Dynamic Programming (DP) is a method for solving complex problems by breaking them down into simpler **overlapping subproblems** and solving each subproblem **only once**.

It is applicable when:
- Subproblems overlap  
- The problem has **optimal substructure**

---

## 1. Key Concepts

### a) Overlapping Subproblems
- The problem can be broken down into subproblems that are reused multiple times.
- Avoid recomputation by storing results.

**Example:**  
Fibonacci sequence  
```
fib(n) = fib(n-1) + fib(n-2)
```

### b) Optimal Substructure
- The optimal solution of a problem can be built from optimal solutions of its subproblems.

**Example:**  
- Shortest path problems  
- Knapsack problem

---

## 2. Approaches

### a) Top-Down (Memoization)
- Uses recursion
- Stores already computed results
- Usually implemented using arrays or hash maps

**Idea:**  
> Solve â†’ Store â†’ Reuse

### b) Bottom-Up (Tabulation)
- Iterative approach
- Solves smaller subproblems first
- Builds up to the final solution

**Idea:**  
> Start from base case â†’ Build forward

---

## 3. Steps to Solve DP Problems

1. Check if the problem can be broken into subproblems
2. Define the **state** (what uniquely identifies a subproblem)
3. Write the **recurrence relation**
4. Decide between:
   - Memoization (Top-Down)
   - Tabulation (Bottom-Up)
5. Define **base cases**
6. Optimize space if possible

---

## 4. Example Problems and Codes

### A) Fibonacci Numbers

#### Top-Down (Memoization)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int fib(int n, vector<int>& dp) {
    if (n <= 1)
        return n;
    if (dp[n] != -1)
        return dp[n];
    return dp[n] = fib(n-1, dp) + fib(n-2, dp);
}

int main() {
    int n = 10;
    vector<int> dp(n + 1, -1);
    cout << "Fibonacci of " << n << " is " << fib(n, dp) << endl;
    return 0;
}
```

#### Bottom-Up (Tabulation)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int fib(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
}

int main() {
    int n = 10;
    cout << "Fibonacci of " << n << " is " << fib(n) << endl;
    return 0;
}
```

---

### B) 0/1 Knapsack Problem

**Problem:**  
Given weights and values of `n` items, put items in a knapsack of capacity `W` to maximize total value.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int knapsack(int n, int W, vector<int>& wt, vector<int>& val, vector<vector<int>>& dp) {
    if (n == 0 || W == 0)
        return 0;

    if (dp[n][W] != -1)
        return dp[n][W];

    if (wt[n - 1] <= W)
        return dp[n][W] = max(
            val[n - 1] + knapsack(n - 1, W - wt[n - 1], wt, val, dp),
            knapsack(n - 1, W, wt, val, dp)
        );
    else
        return dp[n][W] = knapsack(n - 1, W, wt, val, dp);
}

int main() {
    int n = 3, W = 50;
    vector<int> wt = {10, 20, 30};
    vector<int> val = {60, 100, 120};

    vector<vector<int>> dp(n + 1, vector<int>(W + 1, -1));
    cout << "Max value: " << knapsack(n, W, wt, val, dp) << endl;

    return 0;
}
```

---


---

### C) Climbing Stairs Problem

**Problem:**  
You are climbing a staircase with `n` steps.  
Each time, you can climb either **1 step or 2 steps**.  
Find the total number of **distinct ways** to reach the top.

---

#### ðŸ” Explanation (DP Intuition)

- To reach step `n`, you can come from:
  - step `n-1` (1 step jump)
  - step `n-2` (2 step jump)
- So the total ways to reach step `n` is the **sum of ways** to reach `n-1` and `n-2`.

**Recurrence Relation:**
```
dp[n] = dp[n-1] + dp[n-2]
```

**Base Cases:**
```
dp[0] = 1   // one way (stand still)
dp[1] = 1   // one way (1 step)
```

---

#### Top-Down (Memoization)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int climb(int n, vector<int>& dp) {
    if (n <= 1)
        return 1;

    if (dp[n] != -1)
        return dp[n];

    return dp[n] = climb(n - 1, dp) + climb(n - 2, dp);
}

int main() {
    int n = 5;
    vector<int> dp(n + 1, -1);
    cout << "Ways to climb " << n << " steps: " << climb(n, dp) << endl;
    return 0;
}
```

---

#### Bottom-Up (Tabulation)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int climbStairs(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n = 5;
    cout << "Ways to climb " << n << " steps: " << climbStairs(n) << endl;
    return 0;
}
```

---

**Time Complexity:** `O(n)`  
**Space Complexity:** `O(n)`

> ðŸ§  This problem is very similar to Fibonacci and is one of the **best beginner DP problems** to understand state, recurrence, and base cases.

---

## 5. Common DP Problems

- Fibonacci Numbers  
- Climbing Stairs  
- 0/1 Knapsack  
- Coin Change  
- Longest Common Subsequence (LCS)  
- Edit Distance  
- Subset Sum  
- Matrix Chain Multiplication  

---

## 6. Tips

- Clearly define the DP state
- Always identify base cases
- Memoization is good for recursion-heavy problems
- Tabulation is often more efficient
- Try to optimize space where possible

---

## 7. When NOT to Use DP

- When subproblems do not overlap
- When optimal substructure does not exist

---